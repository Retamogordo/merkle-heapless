//! # Static Tree
//! A Merkle Tree implementation that requires no dynamic memory allocations
//! This Merkle tree is implemented as a contiguous memory array and does not betake to dynamic allocations.
//! As such it allows for certain optimizations and compile-time imposed constraints on arity and size boundaries.
//! - no std dependencies (actually no dependencies)
//! - 2, 4, 8,... power of 2 general branching arity
//! - any hash function that takes ```&[u8]``` and returns something that implements ```AsRef<[u8]>```
//! - 99% safe Rust
//! - optionally augmentable or reducible
//! - optional Mountain Range proc macro (when compiled with a mmr-macro feature)
//!
//! # Mountain Range
//!
//! Merkle Mountain Range offers append-only growable Merkle Tree semantics optimized for space.
//!
//! The rules for this implementation of Mountain Range are:
//! - space limitations are defined at compile-time (no dynamic allocations) by number of peaks only
//! - an element is inserted by appending to the right-most peak having a capacity to append a new item
//! - the left-most peak is the highest peak at any moment
//! - when two adjacent peaks have the same height they are recursively merged into the left sibling
//! - roots of the peaks form leaves for the "summit Merkle tree"
//! - the Mountain Range proof is generated by chaining the proof of the corresponding peak with the proof generated by the relevant path in the summit tree
//! - for MMR declared with N peaks, it will handle peaks with heights [0..N] thus simulating a tree with number of leaves in range [0..N*2^N] in case of a binary MMR
//!
//! # Examples
//!
//! ### Hash implementation examples
//! ```rust
//! use std::{
//!     collections::hash_map::DefaultHasher,
//!     hash::{Hash, Hasher},
//! };
//! use merkle_heapless::traits::HashT;
//!
//! #[derive(Debug)]
//! struct Blake2_256Hash;
//! impl HashT for Blake2_256Hash {
//!     type Output = [u8; 32];
//!
//!     fn hash(input: &[u8]) -> Self::Output {
//!         // from Parity's sp_core crate
//!         sp_core::blake2_256(input)
//!     }
//! }
//!
//! #[derive(Debug)]
//! pub struct StdHash;
//! impl HashT for StdHash {
//!     type Output = [u8; 8];
//!
//!     fn hash(input: &[u8]) -> Self::Output {
//!         let mut s = DefaultHasher::new();
//!         input.hash(&mut s);
//!         s.finish().to_ne_bytes()
//!     }
//! }
//! ```
//!
//! ### Proof generation and verification
//! ```rust
//! use merkle_heapless::{StaticBinaryTree};
//! use merkle_heapless::traits::{StaticTreeTrait, ProofValidator};
//! // tree height 3, 8 leaves, 15 total nodes
//! const MAX_HEIGHT: usize = 3;
//! // supposing the YourHash struct exists
//! let mut tree = StaticBinaryTree::<MAX_HEIGHT, YourHash>::try_from(
//!     &[b"apple", b"banana"]
//! ).unwrap();
//!
//! let proof = tree.generate_proof(0);
//! assert!(proof.validate(b"apple"));
//! ```
//!
//! ### Replace and remove leaf
//! ```rust
//! // snip
//! // replace
//! tree.replace(5, b"cherry");
//! let proof = tree.generate_proof(5);
//! assert!(proof.validate(b"cherry"));
//! // remove
//! tree.replace(1, &[]);
//! let proof = tree.generate_proof(1);
//! assert!(!proof.validate(b"banana"));
//! let proof = tree.generate_proof(1);
//! assert!(proof.validate(&[]));
//! ```
//!
//! ### Arity other than 2
//! ```rust
//! use merkle_heapless::{StaticTree};
//!
//! const BRANCH_FACTOR: usize = 4;
//! let mut tree = StaticTree::<BRANCH_FACTOR, MAX_HEIGHT, YourHash>::try_from(
//!     &[b"apple", b"banana"]
//! ).unwrap();
//! // same operations can be applied
//! ```
//!
//! ## Mountain Range
//! Include ["mmr_macro"] feature in merkle-heapless dependency
//! ### Declaration and instantiation
//! ```rust
//! // compulsory at the beginning of the .rs file in order the macro to compile
//! #![allow(incomplete_features)]
//! #![feature(generic_const_exprs)]
//! // snip
//! use merkle_heapless::{mmr_macro};
//! // declaration with expicit type name for your MMR
//! mmr_macro::mmr!(Type = FooMMR, BranchFactor = 2, Peaks = 3, Hash = StdHash);
//! let mmr = FooMMR::default();
//! // implicitly creates MerkleMountainRange type
//! mmr_macro::mmr!(BranchFactor = 2, Peaks = 5, Hash = StdHash);
//! // create with default current peak of height 0
//! let mmr = MerkleMountainRange::default();
//! // or create with current peak of height 2
//! let mut mmr = MerkleMountainRange::from_peak(MerkleMountainRangePeak::Peak3(Default::default()));
//! assert_eq!(mmr.peaks()[0].height(), 5 - 3);
//! ```
//! ### Functionality
//! The functionality of Mountain Range is similar to that of the Merkle tree.   
//! ```rust
//! mmr.try_append(b"apple").unwrap();
//! // peak leaf numbers: [1, 0, 0, 0, 0]
//! assert_eq!(mmr.peaks()[0].height(), 0);
//! assert_eq!(mmr.peaks()[0].num_of_leaves(), 1);
//! assert_eq!(mmr.peaks()[1].num_of_leaves(), 0);
//! let proof = mmr.generate_proof(0);
//! assert!(proof.validate(b"apple"));
//! ```

#![cfg_attr(not(test), no_std)]
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]
#![feature(trivial_bounds)]
#![warn(missing_docs)]
/// contains implementation of an extention for a Merkle Tree that can be augmented into a bigger tree
// and merge a smaller tree into the tree
pub mod augmentable;
/// contains implementation of an extention for a Merkle Tree that can remove leaf, compact and reduce
/// the tree to a smaller tree.
pub mod compactable;
/// module containing [Proof] implementation the [StaticTree] generates
pub mod proof;
/// module declaring basic traits for tree and proof
pub mod traits;
mod utils;

#[cfg(feature = "mmr_macro")]
pub use mmr_macro;

use core::fmt::Debug;
use core::mem::size_of;

use crate::proof::Proof;
use crate::traits::{HashT, ProofBuilder, StaticTreeTrait};
use crate::utils::{hash_merged_slice, Assert, IsTrue};
/// type alias for [StaticTree] with arity of 2
pub type StaticBinaryTree<const HEIGHT: usize, H, PB = Proof<2, HEIGHT, H>> =
    StaticTree<2, HEIGHT, H, PB>;
/// Basic statically-allocated Merkle Tree
pub struct StaticTree<
    const BRANCH_FACTOR: usize,
    const HEIGHT: usize,
    H,
    PB = Proof<BRANCH_FACTOR, HEIGHT, H>,
> where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    hashes: [H::Output; total_size!(BRANCH_FACTOR, HEIGHT)],
    prefixed_buffer: [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())],
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB>
    StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    const TOTAL_SIZE: usize = total_size!(BRANCH_FACTOR, HEIGHT);
    const BASE_LAYER_SIZE: usize = layer_size!(BRANCH_FACTOR, HEIGHT, 0);
    const BYTES_IN_CHUNK: usize = chunk_size!(BRANCH_FACTOR, size_of::<H::Output>());

    fn create(input_len: usize) -> Result<Self, ()> {
        (input_len <= Self::BASE_LAYER_SIZE)
            .then(|| Self {
                hashes: [H::Output::default(); total_size!(BRANCH_FACTOR, HEIGHT)],
                prefixed_buffer: [1u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())],
            })
            .ok_or(())
    }
    /// creates a tree from an input if possible
    pub fn try_from(input: &[&[u8]]) -> Result<Self, ()> {
        Self::create(input.len()).map(|this| this.from_inner(input, 0))
    }

    fn from_inner(mut self, input: &[&[u8]], prefix: u8) -> Self {
        const MAX_INPUT_LEN: usize = 1000;

        // check input can be hold in base layer and branch factor is of power of 2
        // fill the base layer
        let mut prefixed = [prefix; MAX_INPUT_LEN];
        for (i, d) in input.iter().enumerate() {
            prefixed[1..d.len() + 1].copy_from_slice(d);
            self.hashes[i] = H::hash(&prefixed[0..d.len() + 1]);
        }
        // pad the rest of hashes in the base layer
        for i in input.len()..Self::BASE_LAYER_SIZE {
            self.hashes[i] = H::hash(&[]);
        }
        // fill the rest of layers
        self.fill_layers();
        self
    }
    /// creates a tree from hashed leaves (of another tree)
    pub fn try_from_leaves(leaves: &[H::Output]) -> Result<Self, ()> {
        Self::create(leaves.len()).map(|this| this.from_leaves_inner(leaves))
    }

    fn from_leaves_inner(mut self, leaves: &[H::Output]) -> Self {
        for (i, leaf) in leaves.iter().enumerate() {
            self.hashes[i] = *leaf;
        }
        // pad the rest of hashes in the base layer
        for i in leaves.len()..Self::BASE_LAYER_SIZE {
            self.hashes[i] = H::hash(&[]);
        }
        // fill the rest of layers
        self.fill_layers();
        self
    }

    fn hash_merged_slice(&mut self, index: usize, prefix: u8) -> H::Output
    {
        let chunk = unsafe { core::slice::from_raw_parts(self.hashes[index].as_ref().as_ptr(), Self::BYTES_IN_CHUNK) };
        let len = self.prefixed_buffer.len();

        self.prefixed_buffer[1..len].copy_from_slice(chunk);
        
        H::hash(&self.prefixed_buffer)
    }

    fn fill_layers(&mut self) {
        let mut start_ind = 0;
        let mut next_layer_ind = Self::BASE_LAYER_SIZE;

        let prefix = 1;
        let mut j = next_layer_ind;
        while next_layer_ind < Self::TOTAL_SIZE {
            // hash packed siblings of the current layer and fill the upper layer
            for i in (start_ind..next_layer_ind).step_by(BRANCH_FACTOR) {
                // hash concatenated siblings from the contiguous memory
                // each element has (BRANCH_FACTOR-1) siblings
                // store it as a parent hash
                self.hashes[j] = self.hash_merged_slice(i, prefix);

                j += 1;
            }
            // move on to the upper layer
            start_ind = next_layer_ind;
            next_layer_ind = j;
        }
    }

    fn parent_index_and_base(
        &self,
        height: usize,
        layer: usize,
        layer_base: usize,
    ) -> (usize, usize) {
        let curr_layer_len = layer_size!(BRANCH_FACTOR, HEIGHT, layer);
        let parent_layer_base = layer_base + curr_layer_len;
        let parent_index = parent_layer_base + (height - layer_base) / BRANCH_FACTOR;

        (parent_index, parent_layer_base)
    }

    fn replace_inner(&mut self, index: usize) {
        let mut layer_base = 0;
        let mut index = index;

        let prefix = 1;
        // start from the base layer and propagate the new hashes upwords
        for layer in 0..HEIGHT {
            let offset = index & (BRANCH_FACTOR - 1); // index modulo BRANCH_FACTOR
            let aligned = index - offset;

            let parent_hashed = self.hash_merged_slice(aligned, prefix);

            (index, layer_base) = self.parent_index_and_base(index, layer, layer_base);

            self.hashes[index] = parent_hashed;
        }
    }
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB> StaticTreeTrait<H, PB>
    for StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    /// generate proof at given index on base layer
    fn generate_proof(&mut self, index: usize) -> PB {
        let mut proof = PB::from_root(self.root());
        let mut layer_base = 0;
        let mut index = index;

        for layer in 0..HEIGHT {
            let offset = index & (BRANCH_FACTOR - 1); // index modulo BRANCH_FACTOR (power of 2)
            let aligned = index - offset;

            proof.push(offset, &self.hashes[aligned..]);

            (index, layer_base) = self.parent_index_and_base(index, layer, layer_base);
        }
        proof
    }
    /// replace an element at index with input
    /// panics if index is out of leaf layer bound
    fn replace(&mut self, index: usize, input: &[u8]) {
        const MAX_INPUT_LEN: usize = 1000;

        // check input can be hold in base layer and branch factor is of power of 2
        // fill the base layer
        let mut prefixed = [0u8; MAX_INPUT_LEN];
        prefixed[1..input.len() + 1].copy_from_slice(input);
        self.hashes[index] = H::hash(&prefixed[0..input.len() + 1]);

//        self.hashes[index] = H::hash(input);
        self.replace_inner(index);
    }
    fn replace_leaf(&mut self, index: usize, leaf: H::Output) {
        self.hashes[index] = leaf;
        self.replace_inner(index);
    }
    fn root(&self) -> H::Output {
        self.hashes[Self::TOTAL_SIZE - 1]
    }
    fn leaves(&self) -> &[H::Output] {
        &self.hashes[..layer_size!(BRANCH_FACTOR, HEIGHT, 0)]
    }
    fn base_layer_size(&self) -> usize {
        layer_size!(BRANCH_FACTOR, HEIGHT, 0)
    }
    fn branch_factor(&self) -> usize {
        BRANCH_FACTOR
    }
    fn height(&self) -> usize {
        HEIGHT
    }
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB> Clone
    for StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    fn clone(&self) -> Self {
        Self {
            hashes: self.hashes.clone(),
            prefixed_buffer: self.prefixed_buffer.clone(),
        }
    }
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB> Copy
    for StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB> Default
    for StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    fn default() -> Self {
        Self {
            hashes: [H::Output::default(); total_size!(BRANCH_FACTOR, HEIGHT)],
            prefixed_buffer: [1u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())],
        }
    }
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB> PartialEq
    for StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    fn eq(&self, other: &Self) -> bool {
        self.hashes == other.hashes
    }
}

impl<const BRANCH_FACTOR: usize, const HEIGHT: usize, H, PB> Debug
    for StaticTree<BRANCH_FACTOR, HEIGHT, H, PB>
where
    [(); total_size!(BRANCH_FACTOR, HEIGHT)]: Sized,
    [u8; prefixed_size!(BRANCH_FACTOR, size_of::<H::Output>())]: Sized,
    Assert<{ is_pow2!(BRANCH_FACTOR) }>: IsTrue,
    H: HashT,
    PB: ProofBuilder<H>,
{
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
        writeln!(f, "[branch factor]:   {BRANCH_FACTOR}")?;
        writeln!(f, "[height]:          {HEIGHT}")?;
        writeln!(f, "[total size]:      {}", Self::TOTAL_SIZE)?;
        writeln!(f, "[hash output len]: {} bytes", size_of::<H::Output>())?;
        write!(f, "{:?}", self.hashes)
    }
}
